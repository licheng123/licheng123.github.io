---
layout:     post
title:      Retrofit工作原理
subtitle:   Retrofit与okhttp关系
date:       2019-12-20
author:     BY
header-img: img/post-bg-BJJ.jpg
catalog: true
tags:
    - BJJ
---

### 目录

- okhttp 与 apache http
- okhttp工作流程
- okhttp同步使用
- okhttp异步使用
- okhttp连接池介绍
- 为什么还要Retrofit以及使用方式
- Retrofit工作原理
- Retrofit中converter 和 callAdapter的使用
- Retrofit中日志的打印



## okhttp 与 apache HttpClient

打进冷宫的HttpClient
1. 版本多，兼容差，api更新慢，文档维护差
2. 被Google抛弃
3. 不想用你，理由多的很

我们先看看使用httpclient如何发出请求的

```java
public static String httpGet(String url, Map<String, String> paramsMap) {
        String result = null;
        CloseableHttpClient httpClient = HttpClients.createDefault();

        List<NameValuePair> params = Lists.newArrayList();
        HttpGet method = null;
        try {
            for (Map.Entry<String, String> entry : paramsMap.entrySet()) {
                params.add(new BasicNameValuePair(entry.getKey(), entry.getValue()));
            }
            String str = EntityUtils.toString(new UrlEncodedFormEntity(params, Consts.UTF_8));
            method = new HttpGet(url + "?" + str);
            HttpResponse response = null;
            method.setConfig(requestConfig);
            response = httpClient.execute(method);
            int statusCode = response.getStatusLine().getStatusCode();
            if (statusCode == HttpStatus.SC_OK || statusCode == HttpStatus.SC_CREATED) {
                result = EntityUtils.toString(response.getEntity());
            }
            logger.info("http get访问地址是：：" + url + ", statusCode是：：" + statusCode);
            return result;
        } catch (IOException e) {
            logger.error("http调用失败, url:{}, is:{}", url, e);
            return "";
        } finally {
            if (method != null) {
                method.releaseConnection();
            }
        }
    }
```
上面代码是对httpclient api封装的一段代码，可以看出，对数据处理需要多个步骤；
1. 获取client;
2. 将参数拼接到url；
3. 发送，获取response,对返回数据处理；
4. 异常处理

## OkHttp

作为square公司出品的一个网络请求框架，目前较为流行的网络框架。

OkHttp 特点
1. 设计和实现的首要目标是高效;
2. OkHttp 提供了对最新的 HTTP 协议版本 HTTP/2 和 SPDY 的支持;
3. 同一个主机发出的所有请求都可以共享相同的套接字连接;
4. OkHttp 会使用连接池来复用连接以提高效率;
5. 当网络出现问题时，OkHttp 会自动重试一个主机的多个 IP 地址;
6. OkHttp 也提供了对 HTTP 响应的缓存机制，可以避免不必要的网络请求.

## okhttp工作流程

OKHttp是一款高效的HTTP客户端请求框架，其核心主要有路由、连接协议、拦截器、代理、安全性认证、连接池以

及网络适配，拦截器主要是指添加，移除或者转换请求或者回应的头部信息，

OKHttp3总流程图如下：

<img src="https://images2018.cnblogs.com/blog/809143/201808/809143-20180816162138233-707076029.png" alt="图片替换文本" width="550" height="800" align="bottom" />


## okhttp 同步
使用示例
```java
   public void testOKHttp() {
           try {
               OkHttpClient client = new OkHttpClient();
               Request request = new Request.Builder()
                       .get()
                       .url("http://c3.*.srv/panel/api/v1/articleapi/getPushModel?compId=13816245")
                       .build();
               Response response = client.newCall(request).execute();
               System.out.println("Server: " + response.body().string());
           } catch (Exception e) {
               e.printStackTrace();
           }
       }
```
在使用示例中，使用okhttp看起来代码是少了些，但同httpclient发送请求三个步骤相比，没有本质区别，只不过okhttp创建模式替你简化了。


newCall会创建一个新的Call,并加上监听器，调用execute方法时才开始工作。

如何理解okhttp中的call接口，以及call的实现类realCall.
在okhtp框架中，工作是提交给call来实现的，call里负责调用client,dispatcher,负责异步和同步接口的调用，
每个call里封装了一个request.


```java
   /**
   * Prepares the {@code request} to be executed at some point in the future.
   */
    
   RealCall newRealCall(OkHttpClient client, Request originalRequest, boolean forWebSocket) {
       // 加一个事件监听，后续有用.
       RealCall call = new RealCall(client, originalRequest, forWebSocket);
       call.eventListener = client.eventListenerFactory().create(call);
       return call;
   }
     
   @Override 
   public Response execute() throws IOException {
         //...
         eventListener.callStart(this);
         try {
           // 将call放入队列
           client.dispatcher().executed(this);
           // 拦截器链条
           Response result = getResponseWithInterceptorChain();
           //...
           return result;
           //...
         } finally {
           // 从队列里移除
           client.dispatcher().finished(this);
         }
   }
```
拦截器贯穿在okhhtp的整个请求中,负责观察、修改、记录请求和响应.

主要是针对Request和Response的链式切面处理,

每个拦截器的处理结果向下传递，直到最后一个拦截.

okhttp发送请求的核心流程和方法：
```java
   Response getResponseWithInterceptorChain() throws IOException {
     // Build a full stack of interceptors.
     List<Interceptor> interceptors = new ArrayList<>();
     // 用户自己添加的拦截器，在最外层
     // 应用层拦截器
     interceptors.addAll(client.interceptors());
     // 重试拦截器，重试那些失败或者redirect的请求,在这个拦截器里会创建StreamAllocation连接
     interceptors.add(retryAndFollowUpInterceptor);
     // 请求之前对响应头做了一些检查，并添加一些头，然后在请求之后对响应做一些处理（gzip解压or设置cookie）
     interceptors.add(new BridgeInterceptor(client.cookieJar()));
     // 缓存拦截器，根据用户是否设置缓存来工作
     interceptors.add(new CacheInterceptor(client.internalCache()));
     // 连接拦截器，复用连接池中的连接,利用StreamAllocation寻找连接
     interceptors.add(new ConnectInterceptor(client));
     // 网络拦截器
     if (!forWebSocket) {
       interceptors.addAll(client.networkInterceptors());
     }
     // 数据传输拦截
     interceptors.add(new CallServerInterceptor(forWebSocket));
 
     Interceptor.Chain chain = new RealInterceptorChain(interceptors, null, null, null, 0,
         originalRequest, this, eventListener, client.connectTimeoutMillis(),
         client.readTimeoutMillis(), client.writeTimeoutMillis());
 
     return chain.proceed(originalRequest);
   }
```
拦截器按照顺序嵌套执行，第一个拦截器要等待第二个拦截器返回Response果后，继续处理Response，第二个等第三个返回结果，依次内推。

## okhttp 异步
使用示例
```java
   public void testOKHttp() {
           try {
               OkHttpClient client = new OkHttpClient();
               Request request = new Request.Builder()
                       .get()
                       .url("http://c3.*.srv/panel/api/v1/articleapi/getPushModel?compId=13816245")
                       .build();
               response = client.newCall(request).enqueue(new Callback() {
                               @Override
                               public void onFailure(Call call, IOException e) {
                                   
                               }
               
                               @Override
                               public void onResponse(Call call, Response response) throws IOException {
               
                               }
                           });
           } catch (Exception e) {
               e.printStackTrace();
           }
       }
```

RealCall对象中实现异步请求 call.enqueue(new Callback())

```java
public void enqueue(Callback responseCallback) {
        synchronized(this) {
            if (this.executed) {
                throw new IllegalStateException("Already Executed");
            }

            this.executed = true;
        }

        this.captureCallStackTrace();
        this.eventListener.callStart(this);
        this.client.dispatcher().enqueue(new RealCall.AsyncCall(responseCallback));
    }
```

 Dispatcher 去分发一个异步任务;
 
 在call了有个队列与异步相关：runningAsyncCalls 和 readyAsyncCalls
 
 当满足正在执行的请求 <64 ，并同一个主机 <5 请求时，放在runningAsyncCalls中并立马执行
 
 否则放在等等待队列中
```java
synchronized void enqueue(AsyncCall call) {
    //当正在执行的请求小于64个&&该 call 对应的主机少于5个 Call 时
        if (this.runningAsyncCalls.size() < this.maxRequests && this.runningCallsForHost(call) < this.maxRequestsPerHost) {
            this.runningAsyncCalls.add(call);
            this.executorService().execute(call);
        } else {
            this.readyAsyncCalls.add(call);
        }

    }
```

AsyncCall是真正的异步执行者
```java
final class AsyncCall extends NamedRunnable {
        private final Callback responseCallback;

        AsyncCall(Callback responseCallback) {
            super("OkHttp %s", new Object[]{RealCall.this.redactedUrl()});
            this.responseCallback = responseCallback;
        }

        protected void execute() {
            boolean signalledCallback = false;

            try {
                Response response = RealCall.this.getResponseWithInterceptorChain();
                if (RealCall.this.retryAndFollowUpInterceptor.isCanceled()) {
                    signalledCallback = true;
                    this.responseCallback.onFailure(RealCall.this, new IOException("Canceled"));
                } else {
                    signalledCallback = true;
                    this.responseCallback.onResponse(RealCall.this, response);
                }
            } catch (IOException var6) {
                ...
            } finally {
                RealCall.this.client.dispatcher().finished(this);
            }

        }

private <T> void finished(Deque<T> calls, T call, boolean promoteCalls) {
        int runningCallsCount;
        Runnable idleCallback;
        synchronized(this) {
            if (!calls.remove(call)) {
                throw new AssertionError("Call wasn't in-flight!");
            }

            //结束当前call并开始下个call任务
            if (promoteCalls) {
                this.promoteCalls();
            }
            ......
        }

    }

    }
```


okhttp使用拦截器来完成大量工作

###  okhttp 连接池

okhttp通过连接池来减小响应延迟。okhttp会与服务器建立连接，
并将socket的io封装到HttpStream（发送请求和接收response）中，这些都在ConnectInterceptor中完成。

```java
HttpCodec httpCodec = streamAllocation.newStream(client, chain, doExtensiveHealthChecks);

public class StreamAllocation {
    private RealConnection findConnection(int connectTimeout, int readTimeout, int writeTimeout,
          int pingIntervalMillis, boolean connectionRetryEnabled) throws IOException {
        ...
        synchronized (connectionPool) {
            ...
          // Attempt to use an already-allocated connection. We need to be careful here because our
          // already-allocated connection may have been restricted from creating new streams.
          if (result == null) {
            // Attempt to get a connection from the pool.
            // 这是个遍历过程：遍历匹配内容池已有socket的address.url().host()
            Internal.instance.get(connectionPool, address, this, null);
            if (connection != null) {
              foundPooledConnection = true;
              result = connection;
            } else {
              selectedRoute = route;
            }
          }
        }
        ...
        if (result != null) {
          // If we found an already-allocated or pooled connection, we're done.
          return result;
        }
    
        if (selectedRoute == null) {
              selectedRoute = routeSelector.next();
              result = new RealConnection(connectionPool, selectedRoute);
        }
        
        // Do TCP + TLS handshakes. This is a blocking operation.
        result.connect(connectTimeout, readTimeout, writeTimeout, address.connectionSpecs(),
                        connectionRetryEnabled);
        
        // 添加进线程池
        synchronized (connectionPool) {
              Internal.instance.put(connectionPool, newConnection);
        }
        
        eventListener.connectionAcquired(call, result);
        return result;
      }
    
}

```


### 为什么还要Retrofit以及使用方式
okhttp 调用比较复杂，需要自己进行封装

Retrofit 优点：

•  可以配置不同HTTP client来实现网络请求，如okhttp、httpclient等；

•  请求的方法参数注解都可以定制；

•  超级解耦；

•  可以配置不同的反序列化工具来解析数据，如json、xml等；

•  使用非常方便灵活；

Retrofit使用示例如下：

PushTest
```java
public class PushTest {
    @Test
        public void testCheckFestival() {
            try {
                String result = requestServiceProxy.getPushModel("13816245");
                System.out.println(result);
            } catch (Exception e) {
                e.printStackTrace();
            }
    }
}
```
RequestServiceProxy
```java
public class RequestServiceProxy {

    private static RequestServiceInterface requestServiceInterface;

    @PostConstruct
    private void init() {
        String host = "http://c3.admin.browser.miui.srv";
        requestServiceInterface = RetrofitUtil
             .getRetrofitInstance(
                     host,
                     RetrofitUtil.getClientBuilder(1000, 1000),
                     GsonConverterFactory.create()
             )
             .create(RequestServiceInterface.class);
    }

    /**
     * @param compId
     * @return
     */
    public String getPushModel(String compId) throws Exception {
        try {
            //统一的返回对象
            JsonObject resp = requestServiceInterface.getPushModel(compId).execute().body();
            return resp.toString();
        } catch (Exception e) {
            throw e;
        }
    }
}
```
RequestServiceInterface
```java
public interface RequestServiceInterface {

    @GET("/panel/api/v1/articleapi/getPushModel")
    Call<JsonObject> getPushModel(@Query("compId") String compId);
}
```

Retrofit工作原理图

![流程图](https://upload-images.jianshu.io/upload_images/8189709-3958ec4296853898.png?imageMogr2/auto-orient/strip|imageView2/2/format/webp.)

流程代码分析

在RequestServiceProxy中，使用外观模式配置了Retrofit参数，并通过create创建对象.

CallAdapter 适配器,默认的DefaultCallAdapterFactory是Call<T>格式，通过自己的适配器，可以将 Call<User> 转换成 Observer<User>、User等

ConvertFactory 返回数据转换器. 通过自己的转换器，可以将Call<JsonObject> 转换成 Call<User>

```java
public final class Retrofit {
    public <T> T create(final Class<T> service) {
        Utils.validateServiceInterface(service);
        if (this.validateEagerly) {
            this.eagerlyValidateMethods(service);
        }

        return Proxy.newProxyInstance(service.getClassLoader(), new Class[]{service}, new InvocationHandler() {
            private final Platform platform = Platform.get();

            public Object invoke(Object proxy, Method method, @Nullable Object[] args) throws Throwable {
                if (method.getDeclaringClass() == Object.class) {
                    return method.invoke(this, args);
                } else if (this.platform.isDefaultMethod(method)) {
                    return this.platform.invokeDefaultMethod(method, service, proxy, args);
                } else {
                    ServiceMethod<Object, Object> serviceMethod = Retrofit.this.loadServiceMethod(method);
                    OkHttpCall<Object> okHttpCall = new OkHttpCall(serviceMethod, args);
                    return serviceMethod.adapt(okHttpCall);
                }
            }
        });
    }
}
```
1. Retrofit.create()  方法创建的代理proxy，返回的是接口的代理；
2. 在执行requestServiceInterface里的方法时，被proxy拦截;
3. ServiceMethod来解析invoke，ServiceMethod里加载有方法的注解、参数、CallAdapter，ResponseConverter;
最终生成一个Request，包含api 的域名、path、http请求方法、请求头、是否有body、是否是multipart等等
4. CallAdapter   Java8 默认使用 DefaultCallAdapterFactory，默认的啥都不做，返回call。

代码里返回结果的代码是 serviceMethod.adapt(okHttpCall)，如果返回的call,则需要再execute().body();

Retrofit默认能否返回Call\<String>格式？
```java
    Call<String> getPushModel(@Query("compId") String compId);
```
默认是不能的，上面介绍可知，这个格式与ConvertFactory有关，而默认使用的GsonConverterFactory不支持
因为GsonConverter里的TypeAdapter对象仅解析json字符串

有两种方法可以处理：
1. 引入官方支持的Converter， Scalars包支持String
2. 自己实现ConverterFactory接口;


Retrofit能否返回String格式？
```java
    String getPushModel(@Query("compId") String compId);
```
默认DefaultCallAdapterFactory是不支持的;
适配器的选择是根据返回对象的格式里选择的，默认的适配器仅支持Call\<T>格式

需要自己实现AdapterFactory 和 ConverterFactory

首先看看图中Converter工作的位置，再看看代码位置
```java
public retrofit2.Response<T> execute() throws IOException {
        okhttp3.Call call;
        ...

        if (this.canceled) {
            call.cancel();
        }

        return this.parseResponse(call.execute()); // call.execute() 就是okhttp里的execute方法，上面已有介绍
    }

retrofit2.Response<T> parseResponse(Response rawResponse) throws IOException {
        ResponseBody rawBody = rawResponse.body();
        rawResponse = rawResponse.newBuilder().body(new OkHttpCall.NoContentResponseBody(rawBody.contentType(), rawBody.contentLength())).build();
        ...
        T body = this.serviceMethod.toResponse(catchingBody);
        return retrofit2.Response.success(body, rawResponse);    
        ...
    }

R toResponse(ResponseBody body) throws IOException {
        return this.responseConverter.convert(body);
    }
```
ResponseConverter 负责对okhttp返回的数据进行格式转换；


首先看看图中Adapter工作的位置，再看看代码位置
```java
public final class Retrofit {
    public <T> T create(final Class<T> service) {
        ...
        ServiceMethod<Object, Object> serviceMethod = Retrofit.this.loadServiceMethod(method);
        OkHttpCall<Object> okHttpCall = new OkHttpCall(serviceMethod, args);
        return serviceMethod.adapt(okHttpCall);
    }
}
```
代码最后一句 serviceMethod.adapt 此时调用的便是 AdapterFactory具体实现类的adapt

系统默认的有两个AdapterFactory：
1. ExecutorCallAdapterFactory 安卓环境使用
2. DefaultCallAdapterFactory 其他情况下使用

事实上，ServiceMethod初始化时,便根据responseType明确了这个方法对应的AdapterFactory 和 ConverterFactory具体实现类;
ServiceMethod 包含api 的域名、path、http请求方法、请求头、是否有body、是否是multipart等等
```java
 ServiceMethod<?, ?> loadServiceMethod(Method method) {
    ...
    synchronized(this.serviceMethodCache) {
        ...
        result = (new retrofit2.ServiceMethod.Builder(this, method)).build();
        return result;
    }
}

 public ServiceMethod build() {
            this.callAdapter = this.createCallAdapter();
            this.responseType = this.callAdapter.responseType();
            responseConverter = createResponseConverter();
            ...
}
```

## Retrofit中日志的打印

在okhttp的流程图中，可以发现拦截器是链式执行的，再最后有个网络拦截器，retrofit的日志通过拦截器来实现，而日志拦截器的位置就在okHttp的网络拦截层

```java
public static OkHttpClient.Builder getClientBuilder(long milliConnectTimeout, long milliReadTimeout) {
        OkHttpClient.Builder httpClientBuilder = new OkHttpClient.Builder();
        //打印网络请求日志
        HttpLoggingInterceptor httpLoggingInterceptor =
                new HttpLoggingInterceptor(new HttpLoggingInterceptor.Logger() {
                    @Override
                    public void log(String s) {
                        System.out.println(s);
                    }
                });
        httpLoggingInterceptor.setLevel(HttpLoggingInterceptor.Level.BODY);
        httpClientBuilder.addInterceptor(httpLoggingInterceptor);
        return httpClientBuilder;
    }
```










Retrofit非常巧妙的用注解来描述一个HTTP请求，将一个HTTP请求抽象成一个Java接口，然后用了Java动态代理的方式，
动态的将这个接口的注解“翻译”成一个HTTP请求，最后再执行这个HTTP请求；
ServiceMethod最终生成一个Request，包含api 的域名、path、http请求方法、请求头、是否有body、是否是multipart等等

```java
 ServiceMethod<?, ?> loadServiceMethod(Method method) {
        ServiceMethod<?, ?> result = (ServiceMethod)this.serviceMethodCache.get(method);
        if (result != null) {
            return result;
        } else {
            synchronized(this.serviceMethodCache) {
                result = (ServiceMethod)this.serviceMethodCache.get(method);
                if (result == null) {
                    result = (new retrofit2.ServiceMethod.Builder(this, method)).build();
                    this.serviceMethodCache.put(method, result);
                }

                return result;
            }
        }
    }

 public ServiceMethod build() {
            this.callAdapter = this.createCallAdapter();
            this.responseType = this.callAdapter.responseType();
            responseConverter = createResponseConverter();
            ...
                for(int var3 = 0; var3 < p; ++var3) {
                    Annotation annotation = var1[var3];
                    this.parseMethodAnnotation(annotation);//遍历解析方法注解
                }
                ...
                    for(p = 0; p < parameterCount; ++p) {
                        Type parameterType = this.parameterTypes[p];
                        //遍历参数
                        this.parameterHandlers[p] = this.parseParameter(p, parameterType, parameterAnnotations);
                    }
                }
            }
        }

private void parseMethodAnnotation(Annotation annotation) {
            if (annotation instanceof DELETE) {
                this.parseHttpMethodAndPath("DELETE", ((DELETE)annotation).value(), false);
            } else if (annotation instanceof GET) {
                this.parseHttpMethodAndPath("GET", ((GET)annotation).value(), false);
            }
            ...
        }

private void parseHttpMethodAndPath(String httpMethod, String value, boolean hasBody) {
            if (this.httpMethod != null) {
                throw this.methodError("Only one HTTP method is allowed. Found: %s and %s.", this.httpMethod, httpMethod);
            } else {
               ...
                    this.relativeUrl = value;
                    this.relativeUrlParamNames = ServiceMethod.parsePathParameters(value);
                }
            }
        }

Call toCall(@Nullable Object... args) throws IOException {
        RequestBuilder requestBuilder = new RequestBuilder(this.httpMethod, this.baseUrl, this.relativeUrl, this.headers, this.contentType, this.hasBody, this.isFormEncoded, this.isMultipart);
        ...
        return this.callFactory.newCall(requestBuilder.build());
    }
```
ServiceMethod最终生成一个Request。