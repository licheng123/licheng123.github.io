---
layout:     post
title:      Retrofit工作原理
subtitle:   Retrofit与okhttp关系
date:       2019-12-20
author:     BY
header-img: img/post-bg-BJJ.jpg
catalog: true
tags:
    - BJJ
---

### 目录

- okhttp 与 apache http
- okhttp工作流程
- okhttp同步使用
- okhttp异步使用
- okhttp连接池介绍
- 为什么还要Retrofit以及使用方式
- Retrofit工作原理



## okhttp 与 apache HttpClient

开始之前，我们想看看使用httpclient如何发出请求的

```java
public static String httpGet(String url, Map<String, String> paramsMap) {
        String result = null;
        CloseableHttpClient httpClient = HttpClients.createDefault();

        List<NameValuePair> params = Lists.newArrayList();
        HttpGet method = null;
        try {
            for (Map.Entry<String, String> entry : paramsMap.entrySet()) {
                params.add(new BasicNameValuePair(entry.getKey(), entry.getValue()));
            }
            String str = EntityUtils.toString(new UrlEncodedFormEntity(params, Consts.UTF_8));
            method = new HttpGet(url + "?" + str);
            HttpResponse response = null;
            method.setConfig(requestConfig);
            response = httpClient.execute(method);
            int statusCode = response.getStatusLine().getStatusCode();
            if (statusCode == HttpStatus.SC_OK || statusCode == HttpStatus.SC_CREATED) {
                result = EntityUtils.toString(response.getEntity());
            }
            logger.info("http get访问地址是：：" + url + ", statusCode是：：" + statusCode);
            return result;
        } catch (IOException e) {
            logger.error("http调用失败, url:{}, is:{}", url, e);
            return "";
        } finally {
            if (method != null) {
                method.releaseConnection();
            }
        }
    }
```
上面代码是对httpclient api封装的一段代码，可以看出，对数据处理需要多个步骤；
1.获取client;2 将参数拼接到url；3.发送，获取response,对返回数据处理；

打进冷宫的HttpClient
1. 版本多，兼容差，api更新慢，文档维护差，程序员们人微言轻，还得用
2. 被Google抛弃，打进冷宫


OkHttp作为square公司出品的一个网络请求框架，目前较为流行的网络框架。

OkHttp 特点
1. 设计和实现的首要目标是高效;
2. OkHttp 提供了对最新的 HTTP 协议版本 HTTP/2 和 SPDY 的支持;
3. 同一个主机发出的所有请求都可以共享相同的套接字连接;
4. OkHttp 会使用连接池来复用连接以提高效率;
5. 当网络出现问题时，OkHttp 会自动重试一个主机的多个 IP 地址;
6. OkHttp 也提供了对 HTTP 响应的缓存机制，可以避免不必要的网络请求.

## okhttp工作流程

OKHttp是一款高效的HTTP客户端，其核心主要有路由、连接协议、拦截器、代理、安全性认证、连接池以

及网络适配，拦截器主要是指添加，移除或者转换请求或者回应的头部信息，

OKHttp3总流程图如下：

![流程图](https://images2018.cnblogs.com/blog/809143/201808/809143-20180816162138233-707076029.png)


## okhttp 同步
使用示例
```java
   public void testOKHttp() {
           try {
               OkHttpClient client = new OkHttpClient();
               Request request = new Request.Builder()
                       .get()
                       .url("http://c3.*.srv/panel/api/v1/articleapi/getPushModel?compId=13816245")
                       .build();
               Response response = client.newCall(request).execute();
               System.out.println("Server: " + response.body().string());
           } catch (Exception e) {
               e.printStackTrace();
           }
       }
```
在使用示例中，使用okhttp看起来代码是少了些，但同httpclient发送请求三个步骤相比，没有本质区别，只不过okhttp创建模式替你简化了。


newCall会创建一个新的Call,并加上监听器，调用execute方法时才开始工作。

如何理解okhttp中的call接口，以及call的实现类realCall.
在okhtp框架中，工作是提交给call来实现的，call里负责调用client,dispatcher,负责异步和同步接口的调用，
每个call里封装了一个request.



```java
   /**
   * Prepares the {@code request} to be executed at some point in the future.
   */
    
   RealCall newRealCall(OkHttpClient client, Request originalRequest, boolean forWebSocket) {
       // 加一个事件监听，后续有用.
       RealCall call = new RealCall(client, originalRequest, forWebSocket);
       call.eventListener = client.eventListenerFactory().create(call);
       return call;
   }
     
   @Override 
   public Response execute() throws IOException {
         //...
         eventListener.callStart(this);
         try {
           // 将call放入队列
           client.dispatcher().executed(this);
           // 拦截器链条
           Response result = getResponseWithInterceptorChain();
           //...
           return result;
           //...
         } finally {
           // 从队列里移除
           client.dispatcher().finished(this);
         }
   }
```
拦截器贯穿在okhhtp的整个请求中
观察，修改以及可能短路的请求输出和响应请求的回来
主要是针对Request和Response的链式切面处理
每个拦截器的处理结果向下传递，直到最后一个拦截
```java
   Response getResponseWithInterceptorChain() throws IOException {
     // Build a full stack of interceptors.
     List<Interceptor> interceptors = new ArrayList<>();
     // 用户自己添加的拦截器，在最外层
     // 应用层拦截器
     interceptors.addAll(client.interceptors());
     // 重试拦截器，重试那些失败或者redirect的请求,在这个拦截器里会创建StreamAllocation连接
     interceptors.add(retryAndFollowUpInterceptor);
     // 请求之前对响应头做了一些检查，并添加一些头，然后在请求之后对响应做一些处理（gzip解压or设置cookie）
     interceptors.add(new BridgeInterceptor(client.cookieJar()));
     // 缓存拦截器，根据用户是否设置缓存来工作
     interceptors.add(new CacheInterceptor(client.internalCache()));
     // 连接拦截器，复用连接池中的连接,利用StreamAllocation寻找连接
     interceptors.add(new ConnectInterceptor(client));
     // 网络拦截器
     if (!forWebSocket) {
       interceptors.addAll(client.networkInterceptors());
     }
     // 数据传输拦截
     interceptors.add(new CallServerInterceptor(forWebSocket));
 
     Interceptor.Chain chain = new RealInterceptorChain(interceptors, null, null, null, 0,
         originalRequest, this, eventListener, client.connectTimeoutMillis(),
         client.readTimeoutMillis(), client.writeTimeoutMillis());
 
     return chain.proceed(originalRequest);
   }
```
拦截器按照顺序嵌套执行，第一个拦截器要等待第二个拦截器返回结果，并处理，以此内推。

## okhttp 异步
使用示例
```java
   public void testOKHttp() {
           try {
               OkHttpClient client = new OkHttpClient();
               Request request = new Request.Builder()
                       .get()
                       .url("http://c3.*.srv/panel/api/v1/articleapi/getPushModel?compId=13816245")
                       .build();
               response = client.newCall(request).enqueue(new Callback() {
                               @Override
                               public void onFailure(Call call, IOException e) {
                                   
                               }
               
                               @Override
                               public void onResponse(Call call, Response response) throws IOException {
               
                               }
                           });
           } catch (Exception e) {
               e.printStackTrace();
           }
       }

public void enqueue(Callback responseCallback) {
        synchronized(this) {
            if (this.executed) {
                throw new IllegalStateException("Already Executed");
            }

            this.executed = true;
        }

        this.captureCallStackTrace();
        this.eventListener.callStart(this);
        this.client.dispatcher().enqueue(new RealCall.AsyncCall(responseCallback));
    }

synchronized void enqueue(AsyncCall call) {
        if (this.runningAsyncCalls.size() < this.maxRequests && this.runningCallsForHost(call) < this.maxRequestsPerHost) {
            this.runningAsyncCalls.add(call);
            this.executorService().execute(call);
        } else {
            this.readyAsyncCalls.add(call);
        }

    }

final class AsyncCall extends NamedRunnable {
        private final Callback responseCallback;

        AsyncCall(Callback responseCallback) {
            super("OkHttp %s", new Object[]{RealCall.this.redactedUrl()});
            this.responseCallback = responseCallback;
        }

        protected void execute() {
            boolean signalledCallback = false;

            try {
                Response response = RealCall.this.getResponseWithInterceptorChain();
                if (RealCall.this.retryAndFollowUpInterceptor.isCanceled()) {
                    signalledCallback = true;
                    this.responseCallback.onFailure(RealCall.this, new IOException("Canceled"));
                } else {
                    signalledCallback = true;
                    this.responseCallback.onResponse(RealCall.this, response);
                }
            } catch (IOException var6) {
                ...
            } finally {
                RealCall.this.client.dispatcher().finished(this);
            }

        }

private <T> void finished(Deque<T> calls, T call, boolean promoteCalls) {
        int runningCallsCount;
        Runnable idleCallback;
        synchronized(this) {
            if (!calls.remove(call)) {
                throw new AssertionError("Call wasn't in-flight!");
            }

            if (promoteCalls) {
                this.promoteCalls();
            }

            runningCallsCount = this.runningCallsCount();
            idleCallback = this.idleCallback;
        }

        if (runningCallsCount == 0 && idleCallback != null) {
            idleCallback.run();
        }

    }

    }


```



okhttp的一大特点是可以使用连接池，所以我们不可避免要看看这个特性

###  okhttp 连接池

okhttp通过连接池来减小响应延迟。okhttp会与服务器建立连接，
并将socket的io封装到HttpStream（发送请求和接收response）中，这些都在ConnectInterceptor中完成。

```java
HttpCodec httpCodec = streamAllocation.newStream(client, chain, doExtensiveHealthChecks);

public class StreamAllocation {
    private RealConnection findConnection(int connectTimeout, int readTimeout, int writeTimeout,
          int pingIntervalMillis, boolean connectionRetryEnabled) throws IOException {
        ...
        synchronized (connectionPool) {
            ...
          // Attempt to use an already-allocated connection. We need to be careful here because our
          // already-allocated connection may have been restricted from creating new streams.
          if (result == null) {
            // Attempt to get a connection from the pool.
            // 这是个遍历过程：遍历匹配内容池已有socket的address.url().host()
            Internal.instance.get(connectionPool, address, this, null);
            if (connection != null) {
              foundPooledConnection = true;
              result = connection;
            } else {
              selectedRoute = route;
            }
          }
        }
        ...
        if (result != null) {
          // If we found an already-allocated or pooled connection, we're done.
          return result;
        }
    
        if (selectedRoute == null) {
              selectedRoute = routeSelector.next();
              result = new RealConnection(connectionPool, selectedRoute);
        }
        
        // Do TCP + TLS handshakes. This is a blocking operation.
        result.connect(connectTimeout, readTimeout, writeTimeout, address.connectionSpecs(),
                        connectionRetryEnabled);
        
        // 添加进线程池
        synchronized (connectionPool) {
              Internal.instance.put(connectionPool, newConnection);
        }
        
        eventListener.connectionAcquired(call, result);
        return result;
      }
    
}

```


### 为什么还要Retrofit以及使用方式
okhttp 调用比较复杂，需要自己进行封装。
Retrofit 优点：
•  可以配置不同HTTP client来实现网络请求，如okhttp、httpclient等；

•  请求的方法参数注解都可以定制；

•  超级解耦；

•  可以配置不同的反序列化工具来解析数据，如json、xml等；

•  使用非常方便灵活；

Retrofit使用示例
```java
public class RequestServiceProxy {

    private static RequestServiceInterface requestServiceInterface;

    @PostConstruct
    private void init() {
        String host = "http://c3.admin.browser.miui.srv";
        requestServiceInterface = RetrofitUtil
             .getRetrofitInstance(
                     host,
                     RetrofitUtil.getClientBuilder(1000, 1000),
                     GsonConverterFactory.create()
             )
             .create(RequestServiceInterface.class);
    }

    /**
     * @param compId
     * @return
     */
    public String getPushModel(String compId) throws Exception {
        try {
            //统一的返回对象
            JsonObject resp = requestServiceInterface.getPushModel(compId).execute().body();
            return resp.toString();
        } catch (Exception e) {
            throw e;
        }
    }

@Test
    public void testCheckFestival() {
        try {
            String result = requestServiceProxy.getPushModel("13816245");
            System.out.println(result);
        } catch (Exception e) {
            e.printStackTrace();
        }
}

}

public interface RequestServiceInterface {

    @GET("/panel/api/v1/articleapi/getPushModel")
    Call<JsonObject> getPushModel(@Query("compId") String compId);
}

```

Retrofit工作原理图
![流程图](https://upload-images.jianshu.io/upload_images/8189709-3958ec4296853898.png?imageMogr2/auto-orient/strip|imageView2/2/format/webp.)

流程代码分析
```java
public final class Retrofit {
    public <T> T create(final Class<T> service) {
        Utils.validateServiceInterface(service);
        if (this.validateEagerly) {
            this.eagerlyValidateMethods(service);
        }

        return Proxy.newProxyInstance(service.getClassLoader(), new Class[]{service}, new InvocationHandler() {
            private final Platform platform = Platform.get();

            public Object invoke(Object proxy, Method method, @Nullable Object[] args) throws Throwable {
                if (method.getDeclaringClass() == Object.class) {
                    return method.invoke(this, args);
                } else if (this.platform.isDefaultMethod(method)) {
                    return this.platform.invokeDefaultMethod(method, service, proxy, args);
                } else {
                    ServiceMethod<Object, Object> serviceMethod = Retrofit.this.loadServiceMethod(method);
                    OkHttpCall<Object> okHttpCall = new OkHttpCall(serviceMethod, args);
                    return serviceMethod.adapt(okHttpCall);
                }
            }
        });
    }
}
```
1. Retrofit.create()  方法创建的代理proxy，返回的是接口的代理；
2. 在执行requestServiceInterface里的方法时，被proxy拦截;
3. ServiceMethod来解析invoke，ServiceMethod里加载有方法的注解、参数、CallAdapter，ResponseConverter;
最终生成一个Request，包含api 的域名、path、http请求方法、请求头、是否有body、是否是multipart等等
4. CallAdapter  CallAdapter有四个工厂，分别对应不同的平台，RxJava, Java8, Guava还有一个Retrofit默认的。默认的啥都不做。
简单来说就是用来将Call转成T的一个策略。因为这里具体请求是耗时操作，所以你需要CallAdapter去管理线程。

```java
public retrofit2.Response<T> execute() throws IOException {
        okhttp3.Call call;
        ...

        if (this.canceled) {
            call.cancel();
        }

        return this.parseResponse(call.execute()); // call.execute() 就是okhttp里的execute方法，上面已有介绍
    }

retrofit2.Response<T> parseResponse(Response rawResponse) throws IOException {
        ResponseBody rawBody = rawResponse.body();
        rawResponse = rawResponse.newBuilder().body(new OkHttpCall.NoContentResponseBody(rawBody.contentType(), rawBody.contentLength())).build();
        ...
        T body = this.serviceMethod.toResponse(catchingBody);
        return retrofit2.Response.success(body, rawResponse);    
        ...
    }

R toResponse(ResponseBody body) throws IOException {
        return this.responseConverter.convert(body);
    }
```
ResponseConverter 负责对okhttp返回的数据进行格式转换；


Retrofit非常巧妙的用注解来描述一个HTTP请求，将一个HTTP请求抽象成一个Java接口，然后用了Java动态代理的方式，
动态的将这个接口的注解“翻译”成一个HTTP请求，最后再执行这个HTTP请求；
ServiceMethod最终生成一个Request，包含api 的域名、path、http请求方法、请求头、是否有body、是否是multipart等等

```java
 ServiceMethod<?, ?> loadServiceMethod(Method method) {
        ServiceMethod<?, ?> result = (ServiceMethod)this.serviceMethodCache.get(method);
        if (result != null) {
            return result;
        } else {
            synchronized(this.serviceMethodCache) {
                result = (ServiceMethod)this.serviceMethodCache.get(method);
                if (result == null) {
                    result = (new retrofit2.ServiceMethod.Builder(this, method)).build();
                    this.serviceMethodCache.put(method, result);
                }

                return result;
            }
        }
    }

 public ServiceMethod build() {
            this.callAdapter = this.createCallAdapter();
            this.responseType = this.callAdapter.responseType();
            ...
                for(int var3 = 0; var3 < p; ++var3) {
                    Annotation annotation = var1[var3];
                    this.parseMethodAnnotation(annotation);//遍历解析方法注解
                }
                ...
                    for(p = 0; p < parameterCount; ++p) {
                        Type parameterType = this.parameterTypes[p];
                        //遍历参数
                        this.parameterHandlers[p] = this.parseParameter(p, parameterType, parameterAnnotations);
                    }
                }
            }
        }

private void parseMethodAnnotation(Annotation annotation) {
            if (annotation instanceof DELETE) {
                this.parseHttpMethodAndPath("DELETE", ((DELETE)annotation).value(), false);
            } else if (annotation instanceof GET) {
                this.parseHttpMethodAndPath("GET", ((GET)annotation).value(), false);
            }
            ...
        }

private void parseHttpMethodAndPath(String httpMethod, String value, boolean hasBody) {
            if (this.httpMethod != null) {
                throw this.methodError("Only one HTTP method is allowed. Found: %s and %s.", this.httpMethod, httpMethod);
            } else {
               ...
                    this.relativeUrl = value;
                    this.relativeUrlParamNames = ServiceMethod.parsePathParameters(value);
                }
            }
        }

Call toCall(@Nullable Object... args) throws IOException {
        RequestBuilder requestBuilder = new RequestBuilder(this.httpMethod, this.baseUrl, this.relativeUrl, this.headers, this.contentType, this.hasBody, this.isFormEncoded, this.isMultipart);
        ...
        return this.callFactory.newCall(requestBuilder.build());
    }
```
ServiceMethod最终生成一个Request。