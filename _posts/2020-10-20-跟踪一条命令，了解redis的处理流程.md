---
layout:     post
title:      跟踪一条命令，了解redis的处理流程
subtitle:   redis
date:       2020-10-20
author:     BY
header-img: img/post-bg-BJJ.jpg
catalog: true
tags:
    - lc
---

### 目录

- tomcat接受多个socket请求
- redis的框架接受多个socket请求
- 基础概念：redis协议，redis的文件事件，时间事件
- redis_server的启动 （协议层）
- 队列消费 （业务层）
- 命令执行 （数据层）
- 思考


业务开发中，使用redis的场景特别多，最爱使用的万精油string数据结构。

那么一条string的set命令是如何发到服务端，服务端又是如何获取不执行该命令的。

为了方便理解，文章前期做了些基础讲解。

## tomcat接受多个socket请求

业务开发同学对tomcat不陌生，tomcat容器负责接收外部的http请求，并转交给服务层。

当一个链接发送请求，tomcat就从线程池分配一个线程来承接这个请求，当多个请求过来时，就需要多个线程来处理。
如图：

[![oPfnh.md.png](https://wx1.sbimg.cn/2020/08/06/oPfnh.md.png)](https://sbimg.cn/image/oPfnh)

在多线程的处理中，由于多线程可能存在共享内存，所以需要考虑数据安全性；由于存在对共享内存的竞争，需要注意线程安全；
由于多线程处理工作多，对硬盘cpu内存等资源消耗的也快；

假如现在有个硬性命令，让你开发类似tomcat的容器，但是不能使用多线程，对于外部多个请求同时进来，改如何设计架构。
是不是可以使用队列来存储打过来的请求，然后用一个线程慢慢的处理队列。

同时要求每个客户端的长链接不能独占一个线程。

## redis的框架接受多个socket请求

如图是redis接受socket的简单架构描述，
redis为了高效的处理请求，减少io等待时间，使用了NIO。

另外说明，redis server不是只有一个线程，经常网上谈论的redis单线程是说执行client请求的只有一个线程。

## 基础概念：redis协议,redis的事件,IO

通信协议，类似http协议等，双方之间的约定
当客户端发送 set hello world 时，需要将这个命令按照协议装换，
*3\r\n$3\r\nSET\r\n$5\r\nhello\r\n$5\r\nworld\r\n

*3
$3
SET
$5
hello
$5
world

redis服务器是事件驱动程序，所有的任务都是事件，事件又分为文件事件和时间事件。
文件事件就是socket连接，客户端发来的任务，时间事件是定时任务。

```dtd
struct aeEventLoop {
    int stop;
    aeFileEvent *events; 文件事件数组
    aeFiredEvent *fired;  触发的文件事件数组
    adTimeEvent *timeEventHead;  时间事件链表
}
```
redis中文件事件是指socket的可读可写事件，Redis的socket的读写操作使用非阻塞的I/O多路复用模型。
就是将客户端发起的请求定义成文件事件；
在redis的定时任务定义成时间事件。

redis的多路复用支持4种底层依赖，epoll，evport，kqueue，seletc。
redis启动时会根据系统环境自动选择其中一个作为多路复用的底层支持。

## redis_server的启动



## 思考

1. redis单线程执行可能会发生阻塞的地方
2. 为什么执行前要判断是否同slot
3. 
